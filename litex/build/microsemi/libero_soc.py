# This file is part of LiteX.
#
# Copyright (c) 2018-2019 Florent Kermarrec <florent@enjoy-digital.fr>
# SPDX-License-Identifier: BSD-2-Clause

import os
import sys
import subprocess
import shutil
from shutil import which

from migen.fhdl.structure import _Fragment

from litex.build.generic_platform import *
from litex.build import tools
from litex.build.generic_toolchain import GenericToolchain
from litex.build.microsemi import common

class MicrosemiLiberoSoCToolchain(GenericToolchain):
    attr_translate = {}

    def __init__(self):
        super().__init__()
        self.additional_io_constraints     = []
        self.additional_fp_constraints     = []
        self.additional_timing_constraints = []
        self.ip_cores                      = []
        # --- ADDED: Data structure to hold custom TCL commands ---
        self.cxf_component_tcl             = []

    def add_ip_core(self, name, ip_type, params):
        """
        Adds a Libero IP core to be generated.
        ... (omitted for brevity) ...
        """
        self.ip_cores.append((name, ip_type, params))

    # --- ADDED: Method to add custom component TCL commands ---
    def add_cxf_import(self, tcl_commands_list):
        """
        Adds a list of pre-configured Libero TCL commands 
        (e.g., import_component, configure_core, generate_component) 
        to be included in the project creation script.

        Parameters:
        -----------
        tcl_commands_list : list of str
            A list where each string is a complete TCL command.
        """
        self.cxf_component_tcl.extend(tcl_commands_list)

    def add_placement_constraint(self, instance, x, y):
        """
        Adds a Libero location constraint (PDC) for a specific instance
        using X/Y coordinates.

        Parameters:
        -----------
        instance : str
            The hierarchical instance path from the top module
            (e.g., "my_ram_wrapper_0/bram_instance").
        x : str or int
            The X coordinate for the placement.
        y : str or int
            The Y coordinate for the placement.
        """
        # Format as a PDC "set_location" command using X/Y.
        # We use tcl_name to ensure instance paths and coords
        # are properly quoted (e.g., "{...}").
        pdc_string = f"set_location -inst_name {self.tcl_name(instance)}   -fixed true -x {self.tcl_name(x)} -y {self.tcl_name(y)}"
        
        # Add the formatted string to the list that build_placement_constraints()
        # will later write to the *_fp.pdc file.
        self.additional_fp_constraints.append(pdc_string)
    # --- END OF MODIFIED METHOD ---

    def build(self, platform, *args, **kwargs):
        """Sets family-specific overrides at the start of the build process."""
        device = platform.device.lower()
        if device.startswith("mpf"):
            self.special_overrides = common.microsemi_mpf_special_overrides
        elif device.startswith("m2s") or device.startswith("m2gl"):
            self.special_overrides = common.microsemi_m2s_special_overrides
        else:
            raise ValueError(f"Unsupported device family for device: {platform.device}")
        
        # --- ADDED ---
        # Copy placement constraints from platform to toolchain
        if hasattr(platform, "placement_constraints"):
            # Expecting (instance, x, y) tuples now
            for instance, x, y in platform.placement_constraints:
                self.add_placement_constraint(instance, x, y)
        # --- END ---

        return super().build(platform, *args, **kwargs)

    def build_ip_cores_script(self):
        """Generates a Tcl script to create and generate all defined IP cores."""
        if not self.ip_cores:
            return None # No IP cores to generate

        tcl = [
            "# Autogenerated by LiteX for Libero IP Core Generation\n"
        ]
        for name, ip_type, params in self.ip_cores:
            # Format parameters into the Tcl string format: {"KEY1:VAL1" "KEY2:VAL2"}
            param_str = " ".join([f'"{k}:{v}"' for k, v in params.items()])

            tcl.append(f"puts \"## Generating IP Core: {name} ({ip_type})\"")
            tcl.append(" ".join([
                "create_and_configure_core",
                f"-core_vlnv {{{ip_type}}}", # Use -core_vlnv for full IP name
                f"-component_name {{{name}}}",
                f"-params {{{param_str}}}"
            ]))
            tcl.append("") # Newline for readability

        ip_script_filename = self._build_name + "_ip.tcl"
        tools.write_to_file(ip_script_filename, "\n".join(tcl))
        return ip_script_filename

    #@classmethod
    #def tcl_name(cls, name):
    #    return "{" + name + "}"
    @classmethod
    def tcl_name(cls, name):
        # Convert name to string to handle integers (like x/y coords)
        return "{" + str(name) + "}"

    #
    # IO Constraint Generation
    #

    def _format_io_pdc_helper(self, signame, pin, others, set_io_cmd, pin_kw, iostd_kw, res_pull_kw):
        """Helper function to format PDC IO constraints."""
        r = f"{set_io_cmd} {self.tcl_name(signame)} "
        for c in ([Pins(pin)] + others):
            if isinstance(c, Pins):
                r += f"-{pin_kw} {c.identifiers[0]} "
            elif isinstance(c, IOStandard):
                r += f"-{iostd_kw} {c.name} "
            elif isinstance(c, Misc):
                if c.misc: # Only add if Misc is non-empty
                    r += f"-{res_pull_kw} {c.misc} "
        #r += "-fixed true\n"
        return r

    def _format_io_pdc_mpf(self, signame, pin, others):
        """Formats a PDC line for PolarFire devices."""
        return self._format_io_pdc_helper(signame, pin, others,
            set_io_cmd  = "set_io -port_name",
            pin_kw      = "pin_name",
            iostd_kw    = "io_std",
            res_pull_kw = "RES_PULL")

    def _format_io_pdc_m2s(self, signame, pin, others):
        """Formats a PDC line for SmartFusion2/IGLOO2 devices."""
        return self._format_io_pdc_helper(signame, pin, others,
            set_io_cmd  = "set_io",
            pin_kw      = "pinname",
            iostd_kw    = "iostd",
            res_pull_kw = "RES_PULL")

    def build_io_constraints(self):
        """Dispatcher method for IO constraints."""
        device = self.platform.device.lower()
        pdc = []
        for sig, pins, others, resname in self.named_sc:
            for i, p in enumerate(pins):
                pin_name = f"{sig}[{i}]" if len(pins) > 1 else sig
                if device.startswith("mpf"):
                    pdc.append(self._format_io_pdc_mpf(pin_name, p, others))
                else:
                    pdc.append(self._format_io_pdc_m2s(pin_name, p, others))

        pdc.append("\n".join(self.additional_io_constraints))
        pdc_file = self._build_name + "_io.pdc"
        tools.write_to_file(pdc_file, "\n".join(pdc))
        return (pdc_file, "PDC")

    def build_placement_constraints(self):
        pdc = "\n".join(self.additional_fp_constraints)
        pdc_file = self._build_name + "_fp.pdc"
        tools.write_to_file(pdc_file, pdc)
        return (pdc_file, "PDC")

    #
    # Project Build
    #

    def build_project(self):
        """Calls the correct project builder based on device name."""
        # Generate the IP core script before the main project script
        ip_script_filename = self.build_ip_cores_script()

        device = self.platform.device.lower()
        if device.startswith("mpf"):
            return self.build_project_mpf(ip_script_filename)
        elif device.startswith("m2s") or device.startswith("m2gl"):
            return self.build_project_m2s(ip_script_filename)
        else:
            raise ValueError(f"Unsupported device family for device: {self.platform.device}")

    def _get_device_parts(self):
        """Helper to parse device string."""
        device_parts = self.platform.device.split("-")
        if len(device_parts) == 3:
            die, package, speed = device_parts
        elif len(device_parts) == 2:
            die, package = device_parts
            speed = "STD"
        else:
            raise ValueError(f"Unexpected device string format: {self.platform.device}")

        if speed.upper() == "STD":
            formatted_speed = speed
        elif not speed.startswith("-"):
            formatted_speed = "-" + speed
        else:
            formatted_speed = speed

        return die, package, formatted_speed

    def _build_project_common_tcl(self, ip_script_filename):
        """Generates the common Tcl commands for source/constraint import and flow."""
        tcl = []

        # Add Verilog sources
        for filename, language, library, *copy in self.platform.sources:
            filename_tcl = "{" + filename + "}"
            tcl.append(f"import_files -hdl_source {filename_tcl}")

        # Build initial hierarchy from Verilog
        tcl.append("build_design_hierarchy")


        # --- ADDED: Import Pre-configured Components (.cxf) ---
        if self.cxf_component_tcl:
            tcl.append("\n# Importing and Configuring Pre-configured .cxf Components")
            tcl.extend(self.cxf_component_tcl)
            # Re-build hierarchy to ensure imported components are recognized
            tcl.append("build_design_hierarchy") 
            tcl.append("")
        # ------------------------------------------------------

        

        # Source the IP core generation script if it exists
        if ip_script_filename:
            tcl.append(f"\n# Generate and import IP Cores")
            tcl.append(f"source {self.tcl_name(ip_script_filename)}")
            # Re-build hierarchy to include the new IP
            tcl.append("build_design_hierarchy")
            tcl.append("")

        # Set root module *after* all sources (Verilog + IP) are known
        tcl.append(f"set_root -module {self.tcl_name(self._build_name + '::work')}")

        # Import constraint files
        tcl.append(f"import_files -io_pdc {self.tcl_name(self._build_name + '_io.pdc')}")
        tcl.append(f"import_files -fp_pdc {self.tcl_name(self._build_name + '_fp.pdc')}")
        tcl.append(f"import_files -convert_EDN_to_HDL 0 -sdc {self.tcl_name(self._build_name + '.sdc')}")

        # Associate constraints with tools
        tcl.append(" ".join(["organize_tool_files",
            "-tool {SYNTHESIZE}",
            f"-file impl/constraint/{self._build_name}.sdc",
            f"-module {self._build_name}",
            "-input_type {constraint}"
        ]))
        tcl.append(" ".join(["organize_tool_files",
            "-tool {PLACEROUTE}",
            f"-file impl/constraint/io/{self._build_name}_io.pdc",
            f"-file impl/constraint/fp/{self._build_name}_fp.pdc",
            f"-file impl/constraint/{self._build_name}.sdc",
            f"-module {self._build_name}",
            "-input_type {constraint}"
        ]))
        tcl.append(" ".join(["organize_tool_files",
            "-tool {VERIFYTIMING}",
            f"-file impl/constraint/{self._build_name}.sdc",
            f"-module {self._build_name}",
            "-input_type {constraint}"
        ]))
        
        return tcl

    def build_project_mpf(self, ip_script_filename=None):
        """Generates the TCL script for PolarFire devices."""
        tcl = []
        die, package, formatted_speed = self._get_device_parts()
        formatted_family = "PolarFireSoC" if die.upper().startswith("MPFS") else "PolarFire"

        # Create new project
        tcl.append(" ".join([
            "new_project",
            "-location {./impl}",
            f"-name {self.tcl_name(self._build_name)}",
            "-project_description {}",
            "-block_mode 0",
            "-standalone_peripheral_initialization 0",
            "-instantiate_in_smartdesign 1",
            "-ondemand_build_dh 0",
            "-use_enhanced_constraint_flow 1",
            "-hdl {VERILOG}",
            f"-family {self.tcl_name(formatted_family)}",
            f"-die {self.tcl_name(die)}",
            f"-package {self.tcl_name(package)}",
            f"-speed {self.tcl_name(formatted_speed)}",
            "-die_voltage {1.0}",
            "-part_range {IND}",
            "-adv_options {VCCI_1.2_VOLTR:IND}",
            "-adv_options {VCCI_1.5_VOLTR:IND}",
            "-adv_options {VCCI_1.8_VOLTR:IND}",
            "-adv_options {VCCI_2.5_VOLTR:IND}",
            "-adv_options {VCCI_3.3_VOLTR:IND}"
        ]))
        tcl.append("")

        # Add common sources, IPs, constraints, and set root
        tcl += self._build_project_common_tcl(ip_script_filename)

        # Create derived constraints for PLL/DDR/Other IPs
        tcl.append("derive_constraints_sdc")
        tcl.append("")

        # Build flow
        tcl.append("run_tool -name {CONSTRAINT_MANAGEMENT}")
        tcl.append("run_tool -name {SYNTHESIZE}")
        tcl.append("run_tool -name {PLACEROUTE}")
        tcl.append("run_tool -name {GENERATEPROGRAMMINGDATA}")
        tcl.append("run_tool -name {GENERATEPROGRAMMINGFILE}")
        tcl.append("")
        
        # Export bitstream
        tcl.append(f"""
        export_prog_job \\
            -job_file_name {{{self._build_name}}} \\
            -export_dir {{./impl/designer/{self._build_name}/export}} \\
            -bitstream_file_type {{TRUSTED_FACILITY}} \\
            -bitstream_file_components {{FABRIC SNVM}} \\
            -program_design 0 \\
            -design_bitstream_format {{PPD}}
        """)
        
        tools.write_to_file(self._build_name + ".tcl", "\n".join(tcl))
        return self._build_name + ".tcl"

    def build_project_m2s(self, ip_script_filename=None):
        """Generates the TCL script for SmartFusion2 & IGLOO2 devices."""
        tcl = []
        device = self.platform.device.lower()
        family_name = "SmartFusion2" if device.startswith("m2s") else "IGLOO2"
        die, package, formatted_speed = self._get_device_parts()
        
        # Create new project
        tcl.append(" ".join([
            "new_project",
            "-location {./impl}",
            f"-name {self.tcl_name(self._build_name)}",
            "-project_description {}",
            "-block_mode 0",
            "-standalone_peripheral_initialization 0",
            "-instantiate_in_smartdesign 1",
            "-ondemand_build_dh 0",
            "-use_enhanced_constraint_flow 1", # Note: M2S/IGLOO2 use standard flow
            "-hdl {VERILOG}",
            f"-family {{{family_name}}}",
            f"-die {self.tcl_name(die)}",
            f"-package {self.tcl_name(package)}",
            f"-speed {self.tcl_name(formatted_speed)}",
            "-die_voltage {1.2}",
            "-part_range {IND}",
            "-adv_options {IO_DEFT_STD:LVCMOS 3.3V}",
            "-adv_options {RESTRICTPROBEPINS:1}",
            "-adv_options {PLL_SUPPLY:PLL_SUPPLY_33}",
        ]))
        tcl.append("")

        # Add common sources, IPs, constraints, and set root
        tcl += self._build_project_common_tcl(ip_script_filename)
        
        # Note: 'derive_constraints_sdc' is not typically used for M2S standard flow

        # Build flow
        tcl.append("run_tool -name {CONSTRAINT_MANAGEMENT}")
        tcl.append("run_tool -name {SYNTHESIZE}")
        tcl.append("run_tool -name {PLACEROUTE}")
        tcl.append("run_tool -name {GENERATEPROGRAMMINGDATA}")
        tcl.append("run_tool -name {GENERATEPROGRAMMINGFILE}")
        tcl.append("")
        
        # Export bitstream
        tcl.append(" ".join([
            "export_prog_job",
            f"-job_file_name {{{self._build_name}}}",
            f"-export_dir {{./impl/designer/{self._build_name}/export}}",
            "-bitstream_file_type {TRUSTED_FACILITY}",
            "-bitstream_file_components {FABRIC}",
            "-sanitize_envm  0",
            "-design_bitstream_format {PPD}"
        ]))
        
        tools.write_to_file(self._build_name + ".tcl", "\n".join(tcl))
        return self._build_name + ".tcl"

    #
    # Common Toolchain Methods
    #

    def build_timing_constraints(self, vns):
        sdc = []
        for clk, [period, name] in sorted(self.clocks.items(), key=lambda x: x[0].duid):
            clk_sig = self._vns.get_name(clk)
            if name is None:
                name = clk_sig
            sdc.append(f"create_clock -name {name} -period {str(period)} [get_nets {clk_sig}]")
        
        # Note: Libero SDC parser can be strict.
        # Ensure from/to signals are valid clock roots or pins.
        for from_, to in sorted(self.false_paths, key=lambda x: (x[0].duid, x[1].duid)):
            from_clk_sig = self._vns.get_name(from_)
            to_clk_sig   = self._vns.get_name(to)
            sdc.append(f"set_clock_groups -group [get_clocks -include_generated_clocks -of [get_nets {from_clk_sig}]] -group [get_clocks -include_generated_clocks -of [get_nets {to_clk_sig}]] -asynchronous")
        
        sdc.append("\n".join(self.additional_timing_constraints))
        tools.write_to_file(self._build_name + ".sdc", "\n".join(sdc))
        return (self._build_name + ".sdc", "SDC")

    def build_script(self):
        if sys.platform in ("win32", "cygwin"):
            script_ext = ".bat"
            script_contents = "@echo off\nREM Autogenerated by LiteX\n\n"
        else:
            script_ext = ".sh"
            script_contents = "#!/bin.bash\n# Autogenerated by LiteX\n"
        
        script_contents += f"libero script:{self._build_name}.tcl\n"
        
        script_file = "build_" + self._build_name + script_ext
        tools.write_to_file(script_file, script_contents, force_unix=False)
        
        if sys.platform not in ("win32", "cygwin"):
            os.chmod(script_file, 0o755) # Make executable
            
        return script_file

    def run_script(self, script):
        if os.path.exists("impl"):
            shutil.rmtree("impl")
        
        if which("libero") is None:
            msg = "Unable to find Libero SoC toolchain, please check your PATH.\n"
            raise OSError(msg)

        if sys.platform in ["win32", "cygwin"]:
            shell = ["cmd", "/c"]
            script_cmd = [script]
        else:
            shell = ["bash"]
            script_cmd = ["./" + script]

        if subprocess.call(shell + script_cmd) != 0:
            raise OSError("Subprocess failed")

    def add_false_path_constraint(self, platform, from_, to):
        if (to, from_) not in self.false_paths:
            self.false_paths.add((from_, to))